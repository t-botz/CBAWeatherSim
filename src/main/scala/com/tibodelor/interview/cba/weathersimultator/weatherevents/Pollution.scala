package com.tibodelor.interview.cba.weathersimultator.weatherevents

import java.time.temporal.ChronoUnit
import java.time.{Duration, Instant}

import com.tibodelor.interview.cba.weathersimultator.{City, Coordinates, WeatherMeasurement}


/**
  * Represents the pollution generated by a city
  * Pollution level is going from 0 to 100 and represent the pollution generated per hour
  *
  * @param pollutedCities Cities with their pollution level
  */
case class Pollution(pollutedCities: Map[City, Int]) extends WeatherEvent {

  override def doesImpactArea(coordinates: Coordinates) = pollutedCities.keys.exists(_.station.coordinates == coordinates)

  override def reflectImpactOnMeasurement(measurement: WeatherMeasurement, currentDate: Instant, forecastDate: Instant) = measurement

  //Pollution is generated around
  override def evolve(currentDate: Instant, forecastDate: Instant) = List(
    this
  ) ++ pollutedCities.flatMap { case (city, level) =>
    val pollutionGenerated = Duration.between(currentDate, forecastDate).getSeconds * level / 3600
    val coo = city.station.coordinates
    List[WeatherEvent](
      PollutionLevel(coo, pollutionGenerated),
      PollutionLevel(coo.copy(longitude = coo.longitude + 1), pollutionGenerated / 2),
      PollutionLevel(coo.copy(longitude = coo.latitude + 1), pollutionGenerated / 2),
      PollutionLevel(coo.copy(longitude = coo.longitude - 1), pollutionGenerated / 2),
      PollutionLevel(coo.copy(longitude = coo.latitude - 1), pollutionGenerated / 2),
    )
  }
}

/**
  * Represent pollution particles and their impact on the weather
  * On our planet pollution  affect humidity goes up
  *
  * @param coordinates Coordinate where the pollution is measured
  * @param level       measure of pollution
  */
case class PollutionLevel(coordinates: Coordinates, level: Long) extends WeatherEvent {

  override def doesImpactArea(coordinates: Coordinates) = coordinates == this.coordinates


  override def reflectImpactOnMeasurement(measurement: WeatherMeasurement, currentDate: Instant, forecastDate: Instant) = {
    measurement.copy(humidity = (measurement.humidity + (100 - measurement.humidity) / level).toInt)
  }

  override def evolve(currentDate: Instant, forecastDate: Instant) = {
    val newLevel = level - 1000
    if (newLevel <= 0)
      List()
    else
      List(this.copy(level = newLevel))
  }
}